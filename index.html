<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teleindicador Metro Bilbao</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            margin-bottom: 20px;
        }
        h1 {
            color: #d10000; /* Color de Metro Bilbao */
            text-align: center;
            margin-bottom: 25px;
        }
        .input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        /* Estilo para el input del datalist */
        input[type="text"] {
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #d10000; /* Color de Metro Bilbao */
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            align-self: flex-start;
        }
        button:hover {
            background-color: #a30000;
        }
        .results-section {
            width: 100%;
            margin-top: 20px;
        }
        h2 {
            color: #d10000;
            text-align: center;
            margin-bottom: 15px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
            font-size: 0.95em;
        }
        th {
            background-color: #d10000;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
        .error {
            color: red;
            font-weight: bold;
            text-align: center;
            margin-top: 15px;
        }
        .loading {
            text-align: center;
            margin-top: 20px;
            font-style: italic;
            color: #666;
        }
        .dynamic-results-section {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Teleindicador Metro Bilbao</h1>
        <div class="input-section">
            <label for="stationInput">Selecciona o busca una estación:</label>
            <input type="text" id="stationInput" list="stationList" placeholder="Escribe para buscar...">
            <datalist id="stationList"></datalist>
            <button onclick="consultarTrenes()">Consultar Trenes</button>
        </div>
    </div>

    <div class="container results-section">
        <h2 id="resultsTitle">Próximos Trenes</h2>
        <div id="loadingMessage" class="loading" style="display: none;">Cargando datos...</div>
        <div id="errorMessage" class="error" style="display: none;"></div>
        
        <div id="dynamicResultsContainer">
            </div>
    </div>

    <script>
        const stationOrder = [
            { code: "PLE", name: "Plentzia" },
            { code: "URD", name: "Urduliz" },
            { code: "SOP", name: "Sopela" },
            { code: "LAR", name: "Larrabasterra" },
            { code: "BER", name: "Berango" },
            { code: "IBB", name: "Ibarbengoa" },
            { code: "BID", name: "Bidezabal" },
            { code: "GOB", name: "Gobela" },
            { code: "NEG", name: "Neguri" },
            { code: "ALG", name: "Algorta" },
            { code: "AIB", name: "Aiboa" },
            { code: "ARE", name: "Areeta" },
            { code: "LAM", name: "Lamiako" },
            { code: "LEI", name: "Leioa" },
            { code: "AST", name: "Astrabudua" },
            { code: "ERA", name: "Erandio" },
            { code: "LUT", name: "Lutxana" },
            { code: "KAB", name: "Kabiezes" },
            { code: "STZ", name: "Santurtzi" },
            { code: "PEN", name: "Peñota" },
            { code: "POR", name: "Portugalete" },
            { code: "ABT", name: "Abatxolo" },
            { code: "SES", name: "Sestao" },
            { code: "URB", name: "Urbinaga" },
            { code: "BAG", name: "Bagatza" },
            { code: "BAR", name: "Barakaldo" },
            { code: "ANS", name: "Ansio" },
            { code: "GUR", name: "Gurutzeta / Cruces" },
            { code: "SIN", name: "San Ignazio" },
            { code: "SAR", name: "Sarriko" },
            { code: "DEU", name: "Deustu" },
            { code: "SAM", name: "Santimami / San Mamés" },
            { code: "IND", name: "Indautxu" },
            { code: "MOY", name: "Moyua" },
            { code: "ABA", name: "Abando" },
            { code: "CAV", name: "Zazpikaleak / Casco Viejo" },
            { code: "SAN", name: "Santutxu" },
            { code: "BAS", name: "Basarrate" },
            { code: "BOL", name: "Bolueta" },
            { code: "ETX", name: "Etxebarri" },
            { code: "ARZ", name: "Ariz" },
            { code: "BSR", name: "Basauri" }
        ];

        // Mapeo para búsqueda rápida de nombres de estación por código
        const stationCodes = {};
        stationOrder.forEach(station => {
            stationCodes[station.code] = station.name;
        });

        // Función para poblar el datalist de estaciones al cargar la página
        function populateStationDatalist() {
            const datalistElement = document.getElementById('stationList');
            stationOrder.forEach(station => {
                const option = document.createElement('option');
                // Mostrar nombre (código) para que el usuario lo vea
                option.value = `${station.name} (${station.code})`; 
                datalistElement.appendChild(option);
            });
        }

        document.addEventListener('DOMContentLoaded', populateStationDatalist);

        // Función para extraer el código de la estación del valor del input
        function getStationCodeFromInput(inputValue) {
            // Intenta extraer el código entre paréntesis al final (ej. "ABA")
            const match = inputValue.match(/\(([A-Z]+)\)$/); 
            if (match && match[1]) {
                return match[1]; 
            }
            // Si no se encuentra el formato (Nombre (CÓDIGO)), intenta buscar por el nombre exacto
            for (const code in stationCodes) {
                if (stationCodes[code].toLowerCase() === inputValue.toLowerCase()) {
                    return code;
                }
            }
            return null; // Si no se encuentra un código válido
        }

        // Función para obtener las estaciones de destino relevantes
        function getNeighboringStations(currentStationCode) {
            const neighbors = [];
            const index = stationOrder.findIndex(s => s.code === currentStationCode);

            if (index === -1) {
                return []; // Estación no encontrada
            }

            switch (currentStationCode) {
                case "LUT": // Lutxana
                    neighbors.push({ code: "ERA", name: "Erandio" }); // Anterior en la línea 1/2
                    neighbors.push({ code: "SIN", name: "San Ignazio" }); // Siguiente hacia la bifurcación L1/L2
                    break;
                case "KAB": // Kabiezes (terminal de la L2, solo tiene una dirección "siguiente")
                    neighbors.push({ code: "STZ", name: "Santurtzi" }); // Hacia Santurtzi (siguiente lógica en la línea 2)
                    break;
                case "SIN": // San Ignazio (punto de bifurcación)
                    neighbors.push({ code: "GUR", name: "Gurutzeta / Cruces" }); // Anterior (viene de L2)
                    neighbors.push({ code: "LUT", name: "Lutxana" }); // Anterior (viene de L2)
                    neighbors.push({ code: "SAR", name: "Sarriko" }); // Siguiente (hacia L1/L2 centro)
                    break;
                default:
                    // Lógica general para la mayoría de estaciones
                    if (index > 0) {
                        neighbors.push(stationOrder[index - 1]); // Anterior
                    }
                    if (index < stationOrder.length - 1) {
                        neighbors.push(stationOrder[index + 1]); // Siguiente
                    }
                    break;
            }
            return neighbors;
        }


        async function consultarTrenes() {
            const stationInput = document.getElementById('stationInput');
            // Obtener el valor del input y eliminar espacios en blanco
            const selectedStationValue = stationInput.value.trim(); 
            // Extraer el código de la estación a partir del valor del input
            const stationCode = getStationCodeFromInput(selectedStationValue); 
            
            const errorMessage = document.getElementById('errorMessage');
            const loadingMessage = document.getElementById('loadingMessage');
            const dynamicResultsContainer = document.getElementById('dynamicResultsContainer');
            
            dynamicResultsContainer.innerHTML = ''; // Limpiar resultados anteriores
            errorMessage.style.display = 'none';

            // Validar que se ha seleccionado o introducido una estación válida
            // Se comprueba que se haya extraído un código y que este código exista en nuestra lista de estaciones
            if (!stationCode || !stationCodes[stationCode]) {
                errorMessage.textContent = 'Por favor, selecciona una estación válida de la lista.';
                errorMessage.style.display = 'block';
                return;
            }

            loadingMessage.style.display = 'block';

            const targetDestinations = getNeighboringStations(stationCode);

            if (targetDestinations.length === 0) {
                loadingMessage.style.display = 'none';
                errorMessage.textContent = 'No se pudieron determinar las rutas para esta estación.';
                errorMessage.style.display = 'block';
                return;
            }

            for (const destStation of targetDestinations) {
                const apiDestCode = destStation.code;
                const apiDestName = destStation.name;
                // La URL de la API se mantiene igual
                const url = `https://api.metrobilbao.eus/metro/real-time/${stationCode}/${apiDestCode}`;
                
                const destinationSection = document.createElement('div');
                destinationSection.classList.add('dynamic-results-section');
                dynamicResultsContainer.appendChild(destinationSection);

                const destinationTitle = document.createElement('h3');
                destinationTitle.textContent = `Hacia ${apiDestName} (${apiDestCode})`;
                destinationSection.appendChild(destinationTitle);

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                table.appendChild(thead);
                table.appendChild(tbody);
                destinationSection.appendChild(table);

                thead.innerHTML = `
                    <tr>
                        <th>Tiempo restante</th>
                        <th>Vagones</th>
                        <th>Destino Real</th>
                    </tr>
                `;

                const noTrainsP = document.createElement('p');
                noTrainsP.style.fontStyle = 'italic';
                noTrainsP.style.textAlign = 'center';
                noTrainsP.style.display = 'none';
                noTrainsP.textContent = `No hay trenes próximos hacia ${apiDestName}.`;
                destinationSection.appendChild(noTrainsP);

                try {
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        console.warn(`API respondió con estado ${response.status} para ${stationCode} hacia ${apiDestCode}. Tratando como no hay trenes disponibles.`);
                        noTrainsP.style.display = 'block';
                        continue;
                    }
                    
                    const data = await response.json();
                    
                    if (data && data.trains && data.trains.length > 0) {
                        data.trains.forEach(train => {
                            const row = tbody.insertRow();
                            const timeCell = row.insertCell(0);
                            const wagonsCell = row.insertCell(1);
                            const directionCell = row.insertCell(2);

                            // Pasa ambos valores a formatTime: estimated (minutos) y timerounded (cadena "HH:MM")
                            timeCell.textContent = formatTime(train.estimated, train.timerounded);
                            wagonsCell.textContent = train.wagons || 'N/A';
                            // Asegurarse de que 'direction' de la API se mapee correctamente
                            directionCell.textContent = stationCodes[getStationCodeFromInput(train.direction)] || train.direction;
                        });
                    } else {
                        noTrainsP.style.display = 'block';
                    }
                } catch (error) {
                    console.error(`Error de red o parsing para ${apiDestCode}:`, error);
                    noTrainsP.style.display = 'block'; 
                }
            }
            loadingMessage.style.display = 'none';
        }

        // Función formatTime modificada para aceptar timeEstimated (minutos) y timeRoundedString ("HH:MM")
        function formatTime(timeEstimated, timeRoundedString) {
            const formatMinutesToText = (minutes) => {
                if (minutes === 0) {
                    return 'En estación';
                } else if (minutes === 1) {
                    return '1 minuto';
                } else if (minutes < 60) {
                    return `${minutes} minutos`;
                } else {
                    const hours = Math.floor(minutes / 60);
                    const remainingMinutes = minutes % 60;
                    return `${hours}h ${remainingMinutes}min`;
                }
            };
            
            const estimatedText = formatMinutesToText(timeEstimated);
            
            // timeRoundedString ya es la cadena de la hora (ej: "7:54").
            // Eliminamos comillas dobles si por alguna razón la API las devolviera así, aunque JSON.parse
            // del fetch ya se encargaría de esto normalmente.
            const roundedTimeClean = timeRoundedString ? timeRoundedString.replace(/"/g, '') : 'N/A';
            
            // Formato final: "estimated (timerounded)"
            return `${estimatedText} (${roundedTimeClean})`;
        }
    </script>
</body>
</html>
