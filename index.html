<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teleindicador Metro Bilbao</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            margin-bottom: 20px;
        }
        h1 {
            color: #d10000; /* Color de Metro Bilbao */
            text-align: center;
            margin-bottom: 25px;
        }
        .input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        /* Estilo para el input del datalist */
        input[type="text"] {
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #d10000; /* Color de Metro Bilbao */
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            align-self: flex-start;
        }
        button:hover {
            background-color: #a30000;
        }
        .results-section {
            width: 100%;
            margin-top: 20px;
        }
        h2 {
            color: #d10000;
            text-align: center;
            margin-bottom: 15px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
            font-size: 0.95em;
        }
        th {
            background-color: #d10000;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
        .error {
            color: red;
            font-weight: bold;
            text-align: center;
            margin-top: 15px;
        }
        .loading {
            text-align: center;
            margin-top: 20px;
            font-style: italic;
            color: #666;
        }
        .dynamic-results-section {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Teleindicador Metro Bilbao</h1>
        <div class="input-section">
            <label for="stationInput">Selecciona o busca una estación:</label>
            <input type="text" id="stationInput" list="stationList" placeholder="Escribe para buscar...">
            <datalist id="stationList"></datalist>
            <button onclick="consultarTrenes()">Consultar Trenes</button>
        </div>
    </div>

    <div class="container results-section">
        <h2 id="resultsTitle">Próximos Trenes</h2>
        <div id="loadingMessage" class="loading" style="display: none;">Cargando datos...</div>
        <div id="errorMessage" class="error" style="display: none;"></div>
        
        <div id="dynamicResultsContainer">
            </div>
    </div>

    <script>
        // Definimos las estaciones en el orden lineal que me has proporcionado
        const stationOrder = [
            { code: "PLE", name: "Plentzia" },
            { code: "URD", name: "Urduliz" },
            { code: "SOP", name: "Sopela" },
            { code: "LAR", name: "Larrabasterra" },
            { code: "BER", name: "Berango" },
            { code: "IBB", name: "Ibarbengoa" },
            { code: "BID", name: "Bidezabal" },
            { code: "ALG", name: "Algorta" },
            { code: "AIB", name: "Aiboa" },
            { code: "NEG", name: "Neguri" },
            { code: "GOB", name: "Gobela" },
            { code: "ARE", name: "Areeta" },
            { code: "LAM", name: "Lamiako" },
            { code: "LEI", name: "Leioa" },
            { code: "AST", name: "Astrabudua" },
            { code: "ERA", name: "Erandio" },
            { code: "LUT", name: "Lutxana" },
            { code: "KAB", name: "Kabiezes" },
            { code: "STZ", name: "Santurtzi" },
            { code: "PEN", name: "Peñota" },
            { code: "POR", name: "Portugalete" },
            { code: "ABT", name: "Abatxolo" },
            { code: "SES", name: "Sestao" },
            { code: "URB", name: "Urbinaga" },
            { code: "BAG", name: "Bagatza" },
            { code: "BAR", name: "Barakaldo" },
            { code: "ANS", name: "Ansio" },
            { code: "GUR", name: "Gurutzeta / Cruces" },
            { code: "SIN", name: "San Ignazio" },
            { code: "SAR", name: "Sarriko" },
            { code: "DEU", name: "Deustu" },
            { code: "SAM", name: "Santimami / San Mamés" },
            { code: "IND", name: "Indautxu" },
            { code: "MOY", name: "Moyua" },
            { code: "ABA", name: "Abando" },
            { code: "CAV", name: "Zazpikaleak / Casco Viejo" },
            { code: "SAN", name: "Santutxu" },
            { code: "BAS", name: "Basarrate" },
            { code: "BOL", name: "Bolueta" },
            { code: "ETX", name: "Etxebarri" },
            { code: "ARZ", name: "Ariz" },
            { code: "BSR", name: "Basauri" }
        ];

        const stationCodes = {};
        stationOrder.forEach(station => {
            stationCodes[station.code] = station.name;
        });

        function populateStationDatalist() {
            const datalistElement = document.getElementById('stationList');
            stationOrder.forEach(station => {
                const option = document.createElement('option');
                option.value = `${station.name} (${station.code})`;
                datalistElement.appendChild(option);
            });
        }

        document.addEventListener('DOMContentLoaded', populateStationDatalist);

        function getStationCodeFromInput(inputValue) {
            const match = inputValue.match(/\(([A-Z]+)\)$/);
            if (match && match[1]) {
                return match[1];
            }
            // Si el usuario escribe solo el nombre, intentamos encontrar el código
            for (const code in stationCodes) {
                if (stationCodes[code].toLowerCase() === inputValue.toLowerCase()) {
                    return code;
                }
            }
            return null;
        }

        // Función para obtener las estaciones de destino relevantes
        function getNeighboringStations(currentStationCode) {
            const neighbors = [];
            const index = stationOrder.findIndex(s => s.code === currentStationCode);

            if (index === -1) {
                return []; // Estación no encontrada en nuestro orden
            }

            // Casos especiales de bifurcación o terminal
            switch (currentStationCode) {
                case "LUT": // Lutxana: Puede ir hacia Erandio (L1/L2) o San Ignazio (L1/L2)
                    neighbors.push({ code: "ERA", name: "Erandio" });
                    neighbors.push({ code: "SIN", name: "San Ignazio" });
                    break;
                case "AST": // Astrabudua: Puede ir hacia Leioa o Erandio
                    neighbors.push({ code: "LEI", name: "Leioa" });
                    neighbors.push({ code: "ERA", name: "Erandio" });
                    break;
                case "ERA": // Erandio: Puede ir hacia Astrabudua o Lutxana
                    neighbors.push({ code: "AST", name: "Astrabudua" });
                    neighbors.push({ code: "LUT", name: "Lutxana" });
                    break;
                case "KAB": // Kabiezes: Es una terminal, solo tiene una dirección real hacia Santurtzi
                    neighbors.push({ code: "STZ", name: "Santurtzi" });
                    break;
                case "BSR": // Basauri: Es una terminal, solo tiene una dirección real hacia Ariz
                    neighbors.push({ code: "ARZ", name: "Ariz" });
                    break;
                case "PLE": // Plentzia: Es una terminal, solo tiene una dirección real hacia Urduliz
                    neighbors.push({ code: "URD", name: "Urduliz" });
                    break;
                case "SIN": // San Ignazio: Es el punto de unión/separación clave
                    // L1: hacia Sarriko (centro) y hacia Deustu si viene del otro lado
                    // L2: hacia Gurutzeta/Cruces (Margen Izquierda) y hacia Lutxana
                    
                    // Si San Ignazio es la estación actual, queremos ver trenes hacia sus vecinos:
                    // Hacia Sarriko (tronco común)
                    neighbors.push({ code: "SAR", name: "Sarriko" });
                    // Hacia Gurutzeta/Cruces (L2)
                    neighbors.push({ code: "GUR", name: "Gurutzeta / Cruces" });
                    // Hacia Lutxana (L1)
                    neighbors.push({ code: "LUT", name: "Lutxana" });
                    break;
                
                default:
                    // Para la mayoría de estaciones lineales: un anterior y un siguiente
                    const prevStation = stationOrder[index - 1];
                    const nextStation = stationOrder[index + 1];

                    // Determinar el flujo para evitar ir a estaciones "detrás" de la bifurcación principal
                    // Esto es una simplificación; la API de Metro Bilbao gestiona la lógica de rutas.
                    // Aquí simplemente le damos los vecinos directos según nuestro orden lineal.

                    if (prevStation) {
                        // Consideramos la estación anterior si no es un punto de bifurcación "problemático"
                        // o si estamos en un tramo común donde el anterior es siempre un destino válido.
                        if (!['SIN'].includes(prevStation.code)) { // No añadir SIN si es "anterior" y podría llevar a un bucle lógico no deseado para consultas
                            neighbors.push(prevStation);
                        }
                    }
                    if (nextStation) {
                        // Consideramos la estación siguiente
                        if (!['SIN'].includes(nextStation.code)) {
                            neighbors.push(nextStation);
                        }
                    }

                    // Lógica adicional para asegurar que se consulten destinos "sensatos" desde puntos no-bifurcación
                    // Esto es una capa de seguridad para evitar consultas a destinos que no existen o son ilógicos.
                    // La API de Metro Bilbao ya debería manejar esto, pero mejor ser explícitos.
                    if (currentStationCode === "IND") { // Indautxu -> puede ir a Moyua o Santimami
                        if (!neighbors.some(n => n.code === "MOY")) neighbors.push({code: "MOY", name: "Moyua"});
                        if (!neighbors.some(n => n.code === "SAM")) neighbors.push({code: "SAM", name: "Santimami / San Mamés"});
                    }
                    if (currentStationCode === "MOY") { // Moyua -> puede ir a Abando o Indautxu
                        if (!neighbors.some(n => n.code === "ABA")) neighbors.push({code: "ABA", name: "Abando"});
                        if (!neighbors.some(n => n.code === "IND")) neighbors.push({code: "IND", name: "Indautxu"});
                    }
                    // Y así sucesivamente para estaciones donde el 'orden lineal' no garantiza vecinos lógicos
                    // para la API real-time en ambos sentidos.
                    // Sin una lista completa de rutas de la API, es difícil simularlo perfectamente.
                    // Lo mejor es que la API de Metro Bilbao se encargue de la validación del destino.
                    // Si un par (origen, destino) no es válido, la API debería devolver 404/error.
                    
                    // La lógica por defecto de `getNeighboringStations` simplemente busca el anterior y el siguiente
                    // en la lista `stationOrder`. Si la lista no representa la linealidad de la ruta,
                    // esta función debe ser más inteligente.
                    
                    // Para evitar duplicados o errores con la lógica 'prev/next' en puntos complejos,
                    // es mejor ser explícito para los puntos de bifurcación y terminales como se hizo arriba.
                    // Para el resto, el orden lineal debería ser suficiente si están en un tramo "recto".

                    // Añadimos una verificación para que no se dupliquen vecinos si ya se añadieron
                    // por la lógica del switch o por la linealidad.
                    const uniqueNeighbors = [];
                    const neighborCodes = new Set();
                    neighbors.forEach(n => {
                        if (!neighborCodes.has(n.code)) {
                            uniqueNeighbors.push(n);
                            neighborCodes.add(n.code);
                        }
                    });
                    return uniqueNeighbors;
            }
            // Aseguramos que no haya duplicados si las lógicas anteriores agregaron lo mismo
            const finalNeighbors = [];
            const seenCodes = new Set();
            neighbors.forEach(n => {
                if (!seenCodes.has(n.code)) {
                    finalNeighbors.push(n);
                    seenCodes.add(n.code);
                }
            });
            return finalNeighbors;
        }


        async function consultarTrenes() {
            const stationInput = document.getElementById('stationInput');
            const selectedStationValue = stationInput.value.trim();
            const stationCode = getStationCodeFromInput(selectedStationValue);

            const errorMessage = document.getElementById('errorMessage');
            const loadingMessage = document.getElementById('loadingMessage');
            const dynamicResultsContainer = document.getElementById('dynamicResultsContainer');

            dynamicResultsContainer.innerHTML = '';
            errorMessage.style.display = 'none';

            if (!stationCode || !stationCodes[stationCode]) {
                errorMessage.textContent = 'Por favor, selecciona una estación válida de la lista.';
                errorMessage.style.display = 'block';
                return;
            }

            loadingMessage.style.display = 'block';

            // Obtener las estaciones a las que se puede viajar desde la estación seleccionada
            const targetDestinations = getNeighboringStations(stationCode);

            if (targetDestinations.length === 0) {
                loadingMessage.style.display = 'none';
                errorMessage.textContent = 'No se pudieron determinar las rutas para esta estación. Intenta con otra estación.';
                errorMessage.style.display = 'block';
                return;
            }

            // Usamos Promise.all para hacer todas las llamadas a la API en paralelo
            // y luego procesar los resultados una vez que todas han terminado.
            const fetchPromises = targetDestinations.map(async (destStation) => {
                const apiDestCode = destStation.code;
                const apiDestName = destStation.name;
                const url = `https://api.metrobilbao.eus/metro/real-time/${stationCode}/${apiDestCode}`;

                let trainData = null;
                let hasError = false;

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        // Si la API responde con un error (ej. 404 para una ruta inválida),
                        // lo tratamos como "no hay trenes" para esa dirección.
                        console.warn(`API respondió con estado ${response.status} para ${stationCode} hacia ${apiDestCode}.`);
                        hasError = true;
                    } else {
                        trainData = await response.json();
                    }
                } catch (error) {
                    console.error(`Error de red o parsing para ${apiDestCode}:`, error);
                    hasError = true;
                }

                return {
                    destStation,
                    trainData,
                    hasError
                };
            });

            // Esperar a que todas las promesas se resuelvan
            const allResults = await Promise.all(fetchPromises);

            let anyTrainFound = false;

            // Procesar y mostrar los resultados
            allResults.forEach(({ destStation, trainData, hasError }) => {
                const apiDestName = destStation.name;
                const apiDestCode = destStation.code;

                const destinationSection = document.createElement('div');
                destinationSection.classList.add('dynamic-results-section');
                dynamicResultsContainer.appendChild(destinationSection);

                const destinationTitle = document.createElement('h3');
                destinationTitle.textContent = `Hacia ${apiDestName} (${apiDestCode})`;
                destinationSection.appendChild(destinationTitle);

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                table.appendChild(thead);
                table.appendChild(tbody);
                destinationSection.appendChild(table);

                thead.innerHTML = `
                    <tr>
                        <th>Tiempo restante</th>
                        <th>Vagones</th>
                        <th>Destino Real</th>
                    </tr>
                `;

                const noTrainsP = document.createElement('p');
                noTrainsP.style.fontStyle = 'italic';
                noTrainsP.style.textAlign = 'center';
                noTrainsP.style.display = 'none'; // Por defecto oculto
                noTrainsP.textContent = `No hay trenes próximos hacia ${apiDestName}.`;
                destinationSection.appendChild(noTrainsP);

                if (!hasError && trainData && trainData.trains && trainData.trains.length > 0) {
                    trainData.trains.forEach(train => {
                        const row = tbody.insertRow();
                        const timeCell = row.insertCell(0);
                        const wagonsCell = row.insertCell(1);
                        const directionCell = row.insertCell(2);

                        timeCell.textContent = formatTime(train.estimated, train.timeRounded);
                        wagonsCell.textContent = train.wagons || 'N/A';
                        // La API en 'direction' puede devolver el nombre de la estación o el código.
                        // Usamos stationCodes[code] si es un código, si no, el valor directo.
                        const finalDirectionCode = getStationCodeFromInput(train.direction); // Intenta extraer el código
                        directionCell.textContent = finalDirectionCode ? stationCodes[finalDirectionCode] : train.direction;
                    });
                
